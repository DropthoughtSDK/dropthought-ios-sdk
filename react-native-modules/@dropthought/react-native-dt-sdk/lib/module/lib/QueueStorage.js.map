{"version":3,"sources":["QueueStorage.js"],"names":["loadData","removeData","encryptedStorage","head","tail","append","waitUntil","check","round","Promise","resolve","timeout","setTimeout","QueueStorage","constructor","key","storageKey","queue","initialized","syncToStorage","setItemT","err","console","log","migration","queuedElements","length","initialize","undefined","getItemT","concat","clear","getAll","front","enqueue","element","Array","isArray","dequeue","firstElement"],"mappings":"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","sourcesContent":["/**\n * @description simple queue operation, and sync to async storage with designated key\n */\nimport { loadData, removeData } from './Storage';\nimport encryptedStorage from './encrypted-storage';\nimport { head, tail, append } from 'ramda';\n\n/**\n * @param {() => boolean} check\n * @returns\n */\nconst waitUntil = async (check) => {\n  let round = 0;\n  return new Promise((resolve) => {\n    const timeout = () => {\n      round++;\n      setTimeout(() => {\n        if (check() || round >= 20) {\n          resolve();\n          return;\n        } else {\n          timeout();\n        }\n      }, 300);\n    };\n    timeout();\n  });\n};\n\n/**\n * @example\n *     const basicTextQueue = new QueueStorage({ key: 'Storage-basic-text'})\n *     basicTextQueue.enqueue('a')  // queue: ['a']\n *     basicTextQueue.front() // => 'a'\n *     basicTextQueue.enqueue('b') // queue: ['a', 'b']\n *     basicTextQueue.enqueue(['c', 'd']) // queue: ['a', 'b', 'c', 'd']\n *     basicTextQueue.front() // => 'a'\n *\n *     basicTextQueue.dequeue()  // queue: ['b', 'c', 'd']\n *     basicTextQueue.front() // => 'b'\n * @template T\n */\nexport class QueueStorage {\n  constructor({ key }) {\n    /** @type {string} */\n    this.storageKey = key;\n    /** @type {T[]} */\n    this.queue = [];\n\n    /** @type {boolean | null | undefined} */\n    this.initialized = null; // null -> not start yet, undefined -> in progress, true -> finished\n  }\n\n  /**\n   * @private\n   */\n  async syncToStorage() {\n    if (this.initialized === null) return;\n    if (typeof this.initialized === 'undefined') {\n      await waitUntil(() => this.initialized === true);\n    }\n\n    try {\n      await encryptedStorage.setItemT(this.storageKey, this.queue);\n    } catch (err) {\n      console.log('##### syncToStorage error, err', err);\n    }\n  }\n\n  /**\n   * @private\n   */\n  async migration() {\n    const queuedElements = await loadData(this.storageKey);\n    if (!queuedElements || !queuedElements.length) {\n      // console.log('### no data in', this.storageKey)\n      return;\n    }\n    await encryptedStorage.setItemT(this.storageKey, queuedElements);\n    await removeData(this.storageKey);\n  }\n\n  /**\n   * @public\n   */\n  async initialize() {\n    // only initialize once\n    if (this.initialized === true) return;\n    if (typeof this.initialized === 'undefined') {\n      return waitUntil(() => this.initialized === true);\n    }\n    this.initialized = undefined;\n\n    await this.migration();\n\n    const queuedElements = await encryptedStorage.getItemT(this.storageKey, []);\n\n    this.queue = queuedElements.concat(this.queue);\n    this.initialized = true;\n    await this.syncToStorage();\n  }\n\n  async clear() {\n    this.queue = [];\n    await this.syncToStorage();\n  }\n\n  /**\n   * @returns {T[]}\n   */\n  getAll() {\n    return this.queue;\n  }\n\n  /**\n   * get the first element of the queue\n   * @returns {T|undefined}\n   */\n  front() {\n    return head(this.queue);\n  }\n\n  /**\n   * adding element(s) to the back of the queue\n   * @param {T|[T]} element\n   */\n  enqueue(element) {\n    // if element is an array, use array concat, otherwise, use append\n    if (Array.isArray(element)) {\n      this.queue = this.queue.concat(element);\n    } else {\n      this.queue = append(element, this.queue);\n    }\n    this.syncToStorage();\n  }\n\n  /**\n   * remove an element from the front of the queue\n   * @returns {T|undefined}\n   */\n  dequeue() {\n    const firstElement = head(this.queue);\n    this.queue = tail(this.queue);\n    this.syncToStorage();\n    return firstElement;\n  }\n}\n\nexport default QueueStorage;\n"]}