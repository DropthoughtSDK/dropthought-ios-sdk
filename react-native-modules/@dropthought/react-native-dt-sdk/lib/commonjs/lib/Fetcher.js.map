{"version":3,"sources":["Fetcher.js"],"names":["RENEW_ENDPOINT","DT_API_KEY_HEADER","DEFAULT_TIMEOUT","throwRequestError","mockAxiosResponse","response","name","message","data","error","status","isRequestTimeoutError","isNoInternetError","isTokenValid","jwtToken","jwtPayload","Date","now","exp","e","console","log","setRequestHeader","requestConfig","header","headers","restRequestConfig","Fetcher","constructor","param","baseURL","timeout","Accept","Promise","resolve","undefined","url","init","authToken","apiKey","refreshToken","storeTokens","loadCache","saveCache","defaultRequestConfig","fetchWithTimeout","abortController","AbortController","cancelTimeout","timeoutId","setTimeout","abort","params","Object","keys","filter","key","map","encodeURIComponent","join","fetchURL","fetch","method","body","JSON","stringify","signal","then","r","isJSONContent","get","indexOf","value","entries","json","text","statusText","toString","catch","err","finally","clearTimeout","authorizeConfig","token","Authorization","tokenRenew","renewTokenIfNeeded","accessToken","request","authRequired","cache","result"],"mappings":"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","sourcesContent":["import jwtDecode from 'jwt-decode'\nimport {isNil, pick} from 'ramda'\n\nconst RENEW_ENDPOINT = '/api/token/renew'\nconst DT_API_KEY_HEADER = 'X-DT-API-KEY'\n\nconst DEFAULT_TIMEOUT = 30000 // default timeout: 30 seconds\n\n/**\n * @param {import('axios').AxiosResponse<any>} mockAxiosResponse\n */\nexport const throwRequestError = (mockAxiosResponse) => {\n    throw {\n        response: mockAxiosResponse,\n        name: 'RequestError',\n        message:\n            mockAxiosResponse.data.error ||\n            `Request failed with status code ${mockAxiosResponse.status}`,\n    }\n}\n\n/**\n * @param {Error} error\n */\nexport const isRequestTimeoutError = (error) => error.name === 'RequestTimeout'\n\n/**\n * @param {Error} error\n */\nexport const isNoInternetError = (error) =>\n    error.message === 'Network request failed'\n\nconst isTokenValid = (jwtToken) => {\n    let jwtPayload\n\n    // decode token\n    try {\n        jwtPayload = jwtDecode(jwtToken)\n\n        // check expiration date\n        if (Date.now() >= jwtPayload.exp * 1000) {\n            return false\n        } else {\n            return jwtPayload\n        }\n    } catch (e) {\n        console.log('decode jwt failed', e)\n        return false\n    }\n}\n\n/**\n * @param {RequestConfig} requestConfig\n * @param {object} header\n * @returns {RequestConfig}\n */\nconst setRequestHeader = (requestConfig, header = {}) => {\n    const {headers = {}, ...restRequestConfig} = requestConfig\n    return {\n        headers: {\n            ...headers,\n            ...header,\n        },\n        ...restRequestConfig,\n    }\n}\n\n/**\n * @typedef {object}  InitializeParams\n * @property {string=} baseURL optional, if want to overwrite the baseURL\n * @property {number=} timeout optional, if want to overwrite the default timeout\n * @property {()=>Promise<string>=} authToken - optional, a function that returns the auth token or api-key\n * @property {()=>Promise<string>=} refreshToken - optional, a function that returns the refresh token\n * @property {(authTokens: AuthToken)=>Promise<any>=} storeTokens - optional, a function that tells the engine how to store tokens\n * @property {(url: string)=>Promise<any>=} loadCache - optional, a function that tells the engine how to load cache from this url\n * @property {(url: string, response: {data: any, status: number, statusText: string, headers: object})=>Promise<any>=} saveCache - optional, a function that tells the engine how to save cache\n * @property {string=} apiKey - or simply given the apiKey, optional\n */\nexport class Fetcher {\n    defaultRequestConfig = {\n        baseURL: '',\n        timeout: DEFAULT_TIMEOUT,\n        headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        },\n    }\n\n    /** @type {() => Promise<string>} */\n    authToken = () => Promise.resolve(undefined)\n\n    /** @type {string | undefined} this is for api key version2 */\n    apiKey = undefined\n\n    /** @type {() => Promise<string>} */\n    refreshToken = () => Promise.resolve(undefined)\n\n    /** @type {(authTokens: AuthToken) => Promise<undefined>} */\n    storeTokens = () => Promise.resolve(undefined)\n\n    /**\n     * @template T\n     * @type {(url: string) => Promise<T>}\n     */\n    loadCache = (url) => Promise.resolve(undefined)\n\n    /** @type {(url: string, response: {data: any, status: number, statusText: string}) => Promise<undefined>} */\n    saveCache = (url, response) => Promise.resolve(undefined)\n\n    /**\n     * @param {InitializeParams} param\n     */\n    constructor(param = {}) {\n        this.init(param)\n    }\n\n    /**\n     * @param {InitializeParams} param\n     */\n    init(param = {}) {\n        const {\n            baseURL,\n            timeout,\n            authToken,\n            apiKey,\n            refreshToken,\n            storeTokens,\n            loadCache,\n            saveCache,\n        } = param\n\n        if (baseURL) {\n            this.defaultRequestConfig.baseURL = baseURL\n        }\n        if (!isNil(timeout)) {\n            this.defaultRequestConfig.timeout = timeout\n        }\n\n        if (authToken) {\n            this.authToken = authToken\n        } else if (apiKey) {\n            this.apiKey = apiKey\n            this.authToken = () => Promise.resolve(undefined)\n        }\n\n        if (refreshToken) {\n            this.refreshToken = refreshToken\n        }\n\n        if (storeTokens) {\n            this.storeTokens = storeTokens\n        }\n\n        if (loadCache) {\n            this.loadCache = loadCache\n        }\n\n        if (saveCache) {\n            this.saveCache = saveCache\n        }\n    }\n\n    /**\n     * @template T\n     * @param {string} url\n     * @param {RequestConfig} requestConfig\n     * @returns {import('axios').AxiosPromise<T>}\n     */\n    async fetchWithTimeout(url, requestConfig) {\n        // setting fetch abort (it is supported after RN 0.60)\n        // eslint-disable-next-line no-undef\n        const abortController = new AbortController()\n        const cancelTimeout =\n            requestConfig.timeout ||\n            this.defaultRequestConfig.timeout ||\n            DEFAULT_TIMEOUT\n        const timeoutId = setTimeout(() => {\n            abortController.abort()\n        }, cancelTimeout)\n\n        // compose fetch params\n        const params = Object.keys(requestConfig.params || {})\n            .filter((key) => !isNil(requestConfig.params[key]))\n            .map(\n                (key) =>\n                    `${key}=${encodeURIComponent(requestConfig.params[key])}`,\n            )\n            .join('&')\n        // compose fetch full URL\n        const fetchURL =\n            (requestConfig.baseURL || this.defaultRequestConfig.baseURL) +\n            url +\n            `?${params}`\n\n        return await fetch(fetchURL, {\n            method: requestConfig.method || 'GET',\n            headers: {\n                ...this.defaultRequestConfig.headers,\n                ...requestConfig.headers,\n            },\n            body: requestConfig.body || JSON.stringify(requestConfig.data),\n            signal: abortController.signal,\n        })\n            .then(async (r) => {\n                const isJSONContent =\n                    r.headers\n                        .get('content-type')\n                        .indexOf('application/json') !== -1\n\n                const headers = {}\n                if (r.headers) {\n                    for (const [key, value] of r.headers.entries()) {\n                        headers[key] = value\n                    }\n                }\n\n                /** @type {import('axios').AxiosResponse<any>} */\n                let mockAxiosResponse = {}\n                mockAxiosResponse.status = r.status\n                mockAxiosResponse.data = isJSONContent\n                    ? await r.json()\n                    : await r.text()\n                mockAxiosResponse.headers = headers\n                mockAxiosResponse.statusText = r.status.toString()\n\n                if (r.status >= 200 && r.status < 300) {\n                    return mockAxiosResponse\n                }\n                throwRequestError(mockAxiosResponse)\n            })\n            .catch((err) => {\n                if (err.name === 'AbortError' || err.message === 'Aborted') {\n                    throw {\n                        name: 'RequestTimeout',\n                        message: `Request Timeout of ${cancelTimeout}ms.`,\n                    }\n                }\n                throw err\n            })\n            .finally(() => {\n                // clear timeout when request is final, success or failed\n                clearTimeout(timeoutId)\n            })\n    }\n\n    /**\n     * set the auth token to config\n     * @private\n     * @param {RequestConfig} requestConfig\n     * @returns {Promise<RequestConfig>}\n     */\n    async authorizeConfig(requestConfig) {\n        if (this.apiKey) {\n            return setRequestHeader(requestConfig, {\n                [DT_API_KEY_HEADER]: this.apiKey,\n            })\n        }\n        const token = await this.authToken()\n        if (!token) return requestConfig\n\n        return setRequestHeader(requestConfig, {\n            Authorization: `Bearer ${token}`,\n        })\n    }\n\n    /** @returns {Promise<any>} */\n    async tokenRenew(timeout = DEFAULT_TIMEOUT) {\n        const refreshToken = await this.refreshToken()\n        if (!refreshToken) return\n\n        return this.fetchWithTimeout(RENEW_ENDPOINT, {\n            method: 'POST',\n            data: {\n                refreshToken,\n            },\n            timeout,\n        }).then((response) => {\n            return this.storeTokens(response.data)\n        })\n    }\n\n    /**\n     * it checks if the authToken(accessToken) is valid (check the expiration date)\n     * if it is invalid, renew token\n     * @private\n     * @param {number=} timeout\n     */\n    async renewTokenIfNeeded(timeout) {\n        const refreshToken = await this.refreshToken()\n        if (!refreshToken) return\n\n        const accessToken = await this.authToken()\n        if (!accessToken) return\n\n        if (!isTokenValid(accessToken)) {\n            try {\n                await this.tokenRenew(timeout)\n            } catch (e) {\n                console.log('token renew failed', e.message)\n                throw e\n            }\n        }\n    }\n\n    /**\n     * @public\n     * @template T\n     * @param {string} url\n     * @param {RequestConfig} requestConfig\n     * @returns {import('axios').AxiosPromise<T>}\n     */\n    async request(url, requestConfig) {\n        let authRequired = false\n\n        if (\n            requestConfig.headers?.Authorization ||\n            requestConfig.authRequired\n        ) {\n            authRequired = true\n\n            // refresh token before sending out actual request\n            await this.renewTokenIfNeeded(requestConfig.timeout)\n            requestConfig = await this.authorizeConfig(requestConfig)\n        }\n\n        // read cached response\n        if (requestConfig.cache) {\n            const result = await this.loadCache(url)\n            if (result) return result\n        }\n\n        // if auth is required, but there's no authorization, fail early before making a request\n        if (\n            authRequired &&\n            !requestConfig.headers?.Authorization &&\n            !this.apiKey\n        ) {\n            return throwRequestError({\n                status: 401,\n                statusText: '401',\n                data: {},\n                headers: {},\n            })\n        }\n\n        let response = await this.fetchWithTimeout(url, requestConfig)\n\n        // if this request is authRequired and the response status is 401, try to renew token again\n        if (authRequired && response.status === 401 && !this.apiKey) {\n            await this.tokenRenew(requestConfig.timeout)\n\n            // query again with renewed token\n            requestConfig = await this.authorizeConfig(requestConfig)\n            response = await this.fetchWithTimeout(url, requestConfig)\n        }\n\n        // store response if cache is true\n        if (requestConfig.cache) {\n            await this.saveCache(\n                url,\n                pick(['data', 'status', 'statusText', 'headers'], response),\n            )\n        }\n\n        return response\n    }\n}\n\n/**\n * @typedef {Object} AuthToken\n * @property {string} accessToken\n * @property {string} refreshToken\n */\n\n/**\n * @typedef {Object} CustomRequestConfig\n * @property {boolean} authRequired\n * @property {boolean} cache\n */\n\n/**\n * @typedef {import('axios').AxiosRequestConfig & CustomRequestConfig} RequestConfig\n */\n"]}