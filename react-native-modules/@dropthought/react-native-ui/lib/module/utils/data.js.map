{"version":3,"sources":["data.ts"],"names":["isEmpty","prop","pipe","findIndex","equals","curry","nth","map","EvaluateRuleSet","QuestionBrandType","Other","QuestionMetaDataType","Name","Email","Phone","Number","Date","String","getOptionsFromQuestion","question","options","option","isOther","title","questionBrand","push","metaDataTypeQuestionValidator","value","type","metaDataType","reg","isNaN","test","mandatoryQuestionValidator","feedback","mandatory","answers","undefined","length","questionFeedbackValidator","getPageIndexFromPageId","pageId","survey","transformFeedbacks","pageIndex","feedbacksMap","defaultPageIQAData","questionId","textOrIndexArr","defaultIQAData","s","toString","otherFlag","nextPage","defaultNextPage","pageOrder","pageRuleSet","rules","iQADataArr","nextPageId"],"mappings":"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","sourcesContent":["import { isEmpty, prop, pipe, findIndex, equals, curry, nth, map } from 'ramda';\nimport { EvaluateRuleSet } from './dt-common-lib';\nimport type { Feedback, Question, Option, Survey } from '../data';\n\n/** @enum {'other'} */\nexport const QuestionBrandType = {\n  Other: 'other',\n};\n\n/** @enum {'Date'|'Name'|'Email'|'Phone'|'Number'|'String'} */\nexport const QuestionMetaDataType = {\n  Name: 'Name',\n  Email: 'Email',\n  Phone: 'Phone',\n  Number: 'Number',\n  Date: 'Date',\n  String: 'String',\n};\n\n/**\n * given a Question type, return ['option label1', 'option label2', 'option label3', true]\n * if the type is boolean at the last, it means it is an \"other\" option\n */\nexport const getOptionsFromQuestion = (question: Question): Option[] => {\n  // copy the original array\n  // @ts-ignore\n  const options = (question.options ?? []).map((option: Option) => ({\n    isOther: false,\n    title: option,\n  }));\n  // add additional option when the question brand type is \"other\"\n  if (question.questionBrand === QuestionBrandType.Other) {\n    options.push({\n      isOther: true,\n      // @ts-ignore\n      title: '',\n    });\n  }\n  // @ts-ignore\n  return options;\n};\n\n/**\n * validate if value match metaDataType question' rule\n */\nexport const metaDataTypeQuestionValidator = (\n  question: Question,\n  value: string\n): boolean => {\n  // if it is not a open ended question no need to check, return valid\n  if (question.type !== 'open') return true;\n\n  // no need to check the value when no value or no type\n  if (!value || !question.metaDataType) return true;\n\n  let reg = null;\n\n  switch (question.metaDataType) {\n    case QuestionMetaDataType.Number:\n      // @ts-ignore\n      return !isNaN(value);\n    case QuestionMetaDataType.Date:\n      reg =\n        /^((?:\\d{4}-\\d{2}-\\d{2})|(?:\\d{4}\\/\\d{2}\\/\\d{2})|(?:\\d{4}:\\d{2}:\\d{2}))?( )?(\\d{2}:\\d{2}:\\d{2})?$/;\n      return reg.test(value);\n    case QuestionMetaDataType.Phone:\n      reg = /^\\+[1-9]\\d{1,14}$/;\n      return reg.test(value);\n    case QuestionMetaDataType.Email:\n      reg =\n        /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n      return reg.test(value);\n    default:\n      // no need to check the value\n      return true;\n  }\n};\n\n/**\n * if mandatory question has feedback\n */\nexport const mandatoryQuestionValidator = (\n  question: Question,\n  feedback: Feedback | {} = {}\n): boolean => {\n  if (!question.mandatory) return true;\n\n  // check if feedback has answer\n  return (\n    // @ts-ignore\n    feedback.answers !== undefined &&\n    // @ts-ignore\n    feedback.answers.length &&\n    // @ts-ignore\n    !isEmpty(feedback.answers[0])\n  );\n};\n\n/**\n * validate if question's feedback is valid:\n * metadata type value check, mandatory check\n */\nexport const questionFeedbackValidator = (\n  question: Question | {} = {},\n  feedback: Feedback | {} = {}\n): boolean => {\n  return (\n    // @ts-ignore\n    metaDataTypeQuestionValidator(question, feedback.answers?.[0]) &&\n    // @ts-ignore\n    mandatoryQuestionValidator(question, feedback)\n  );\n};\n\n/**\n * return -1 if not existed\n * @type {(pageId: string, survey: Survey) => number}\n */\nexport const getPageIndexFromPageId = curry((pageId: string, survey: Survey) =>\n  // @ts-ignore\n  pipe(prop('pageOrder'), findIndex(equals(pageId)))(survey)\n);\n\n/**\n * only keep the feedbacks that belongs to a certain page\n * if a question is not answered => textOrIndexArr: ['']\n * also convert the answers to 0-based\n * transform it to IQAData type\n * @type {(pageIndex: number, survey: Survey, feedbacksMap: {[questionId: string]: Feedback} ) => [IQAData]}\n */\nconst transformFeedbacks = (\n  pageIndex: number,\n  survey: Survey,\n  feedbacksMap: { [questionId: string]: Feedback }\n) => {\n  // get the default page IQAData\n  /** @type {IQAData[]} */\n  const defaultPageIQAData = pipe(\n    prop('pages'),\n    // @ts-ignore\n    nth(pageIndex),\n    prop('questions'),\n    map((question) => ({\n      // @ts-ignore\n      questionId: question.questionId,\n      textOrIndexArr: [''],\n    }))\n    // @ts-ignore\n  )(survey);\n\n  // if feedback has answers, use it to replace the default\n  return defaultPageIQAData.map((defaultIQAData) => {\n    const feedback = feedbacksMap[defaultIQAData.questionId];\n    if (feedback && !isEmpty(feedback.answers)) {\n      return {\n        questionId: defaultIQAData.questionId,\n        // @ts-ignore\n        textOrIndexArr: feedback.answers.map((s) => s.toString()),\n        otherFlag: feedback.otherFlag,\n      };\n    }\n    return defaultIQAData;\n  });\n};\n\nexport function nextPage(\n  pageIndex: number,\n  pageId: string,\n  feedbacksMap: { [questionId: string]: Feedback },\n  survey: Survey\n): number {\n  const defaultNextPage = () =>\n    pageIndex >= survey.pageOrder.length - 1 ? -1 : pageIndex + 1;\n\n  // if there's no rule, go to default next page\n  const pageRuleSet = survey.rules[pageId];\n  if (!pageRuleSet || isEmpty(pageRuleSet)) {\n    return defaultNextPage();\n  }\n\n  // apply the rule\n  const iQADataArr = transformFeedbacks(pageIndex, survey, feedbacksMap);\n  const nextPageId = EvaluateRuleSet(pageRuleSet, iQADataArr);\n  if (!nextPageId) {\n    return defaultNextPage();\n  }\n\n  // next page index\n  return getPageIndexFromPageId(nextPageId, survey);\n}\n\n/** @typedef {import('./dt-common-lib/IfcRule').IQAData} IQAData */\n"]}